<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[darknet安卓移植]]></title>
    <url>%2F2019%2F09%2F06%2Fdarknet%E5%AE%89%E5%8D%93%E7%A7%BB%E6%A4%8D%2F</url>
    <content type="text"><![CDATA[darknet2ncnn安卓移植项目使用的版本是老版darknet2ncnn，之后作者适配到了ncnn最新版。 编译安卓版ncnn在linux下编译，查看官方教程即可。注意使用与android studio相同版本的ndk。设置android studio ndk：修改local.properties，ndk.dir=D:\softback\Android\android-ndk-r15c 添加相关源文件将darknet、ncnn、darknet2ncnn相关源文件和头文件按目录添加到cpp目录下，目录结构如下： 123456789├─darknet│ ├─include│ └─src├─darknet2ncnn│ ├─include│ └─src└─ncnn ├─include └─src darknet源码报错：compare.c:17:13 error: initializing &#39;network&#39; (aka &#39;struct network&#39;) with an expression of incompatible type &#39;network *&#39; (aka &#39;struct network *&#39;); dereference with *.修改compare.c，多处对应的指针类型和引用改一下就OK。 在darknet和darknet2ncnn package下new package，添加相关源码，但编译后android studio中该源码目录会显示在cpp目录下，不清楚啥原因，不过不影响编译。 编写Cmakelists.txt这个是重点，很多问题就是没有写好Cmakelists.txt引起的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657cmake_minimum_required(VERSION 2.8.10)set(CMAKE_BUILD_TYPE RELEASE)set(libs &quot;$&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs&quot;)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/darknet2ncnn/include $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/ncnn/include $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/darknet/include $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/darknet2ncnn/src $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/ncnn/src)set(CMAKE_STATIC_LINKER_FLAGS &quot;-lm -pthread -fopenmp -lstdc++&quot;)set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -Ofast -Wno-unused-result -Wfatal-errors -fPIC -fno-rtti -fno-exceptions&quot;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11 -Ofast -Wno-unused-result -Wfatal-errors -fPIC -fno-rtti -fno-exceptions&quot;)add_library (libncnn STATIC IMPORTED)set_target_properties(libncnn PROPERTIES IMPORTED_LOCATION $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/armeabi-v7a/libncnn.a)file(GLOB_RECURSE darknet_src $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/darknet/src/*.c)set(darknet2ncnn_dir $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/darknet2ncnn/src)set(darknet2ncnn_src $&#123;darknet2ncnn_dir&#125;/layer/darknet_activation.cpp $&#123;darknet2ncnn_dir&#125;/layer/darknet_shortcut.cpp $&#123;darknet2ncnn_dir&#125;/layer/yolov1_detection.cpp $&#123;darknet2ncnn_dir&#125;/layer/yolov3_detection.cpp $&#123;darknet2ncnn_dir&#125;/object_detection.cpp $&#123;darknet2ncnn_dir&#125;/register_darknet.cpp $&#123;darknet2ncnn_dir&#125;/darknet2ncnn.cpp)set(ncnn_src $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/ncnn/src)set(lib_src $&#123;darknet_src&#125; $&#123;darknet2ncnn_src&#125; $&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/yolov3-tiny-jni.cpp)add_library( # Sets the name of the library. yolov3_tiny_jni # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). $&#123;lib_src&#125;)find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log)target_link_libraries( # Specifies the target library. yolov3_tiny_jni libncnn jnigraphics # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125;) 错误解决报错：undefined reference to ‘typeinfo for ncnn::Layer’，这个在arm-linux交叉编译时遇到过，添加-fno-rtti编译选项即可。 报错：fatal error: use of undeclared identifier ‘nullptr’，添加-std=c++11编译选项即可。 make project编译成功，so生成位置：app\build\intermediates\cmake\debug\obj\armeabi-v7a\ build apk报错：Cause: org.jetbrains.plugins.gradle.tooling.util.ModuleComponentIdentifierImpl.getModuleIdentifier()Lorg/gradle/api/artifacts/ModuleIdentifier; 更新android studio即可. ex.extract返回-100，一般是没找到目标，这里有两种可能，一种是模型正确检测正确，测试图片本来就没目标，另一种情况就是模型有问题，不能正常检测到我们的目标。我反复检查了测试图片和模型都没问题，最后发现还是加载模型错误： 123456789101112131415private String getPathFromAssets(String assetsFileName)&#123; File f = new File(getCacheDir()+&quot;/&quot;+assetsFileName); if (!f.exists()) try &#123; InputStream is = getAssets().open(assetsFileName); int size = is.available(); byte[] buffer = new byte[size]; is.read(buffer); is.close(); FileOutputStream fos = new FileOutputStream(f); fos.write(buffer); fos.close(); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; return f.getPath();&#125; 之前的模型已经加载到缓存中了，后来我更换过一次模型，但是缓存没删除，还是之前的模型，所以一直检测不到目标，将if (!f.exists())注释掉，每次初始化都重新写入缓存，最后成功检测到目标。 总结其实也比较简单，主要就写了个Cmakelists.txt。参考以下两项目，感谢作者大佬。 参考安卓应用层 darknet2ncnn]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓开发板绕过usb权限对话框]]></title>
    <url>%2F2018%2F07%2F17%2F%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E6%9D%BF%E7%BB%95%E8%BF%87usb%E6%9D%83%E9%99%90%E5%AF%B9%E8%AF%9D%E6%A1%86%2F</url>
    <content type="text"><![CDATA[当我们使用一些usb设备（如usb读卡器）连接到安卓开发板上时，往往会弹出询问usb权限的对话框，即使我们点击默认允许，系统重启后仍然会弹出对话框。很多时候希望板子启动后直接启动程序工作，就需要去掉这个对话框。 一般有两种解决方法，第一种是修改系统源码，找到这部分系统源码，替换掉弹窗部分。这种方法最简单有效，但代价是需要重新编译烧录系统，成本有点高。我没有用这种方法，参考链接有相关博文。这里主要介绍第二种方法。 我们可以伪造一个假的广播，也就是提前封装好点击对话框的工作，直接让自己接收广播，就绕开了那个对话框。步骤如下： 在工程中增加包名为android.hardware.usb的包，并且添加IUsbManager.java文件。文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package android.hardware.usb;public interface IUsbManager extends android.os.IInterface&#123;/** Local-side IPC implementation stub class. */public static abstract class Stub extends android.os.Binder implements android.hardware.usb.IUsbManager &#123; private static final java.lang.String DESCRIPTOR = &quot;android.hardware.usb.IUsbManager&quot;; /** Construct the stub at attach it to the interface. */ public Stub() &#123; throw new RuntimeException( &quot;Stub!&quot; ); &#125; /** * Cast an IBinder object into an android.hardware.usb.IUsbManager * interface, generating a proxy if needed. */ public static android.hardware.usb.IUsbManager asInterface( android.os.IBinder obj) &#123; throw new RuntimeException( &quot;Stub!&quot; ); &#125; @Override public android.os.IBinder asBinder() &#123; throw new RuntimeException( &quot;Stub!&quot; ); &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; throw new RuntimeException( &quot;Stub!&quot; ); &#125; static final int TRANSACTION_getDeviceList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_openDevice = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); static final int TRANSACTION_getCurrentAccessory = (android.os.IBinder.FIRST_CALL_TRANSACTION + 2); static final int TRANSACTION_openAccessory = (android.os.IBinder.FIRST_CALL_TRANSACTION + 3); static final int TRANSACTION_setDevicePackage = (android.os.IBinder.FIRST_CALL_TRANSACTION + 4); static final int TRANSACTION_setAccessoryPackage = (android.os.IBinder.FIRST_CALL_TRANSACTION + 5); static final int TRANSACTION_hasDevicePermission = (android.os.IBinder.FIRST_CALL_TRANSACTION + 6); static final int TRANSACTION_hasAccessoryPermission = (android.os.IBinder.FIRST_CALL_TRANSACTION + 7); static final int TRANSACTION_requestDevicePermission = (android.os.IBinder.FIRST_CALL_TRANSACTION + 8); static final int TRANSACTION_requestAccessoryPermission = (android.os.IBinder.FIRST_CALL_TRANSACTION + 9); static final int TRANSACTION_grantDevicePermission = (android.os.IBinder.FIRST_CALL_TRANSACTION + 10); static final int TRANSACTION_grantAccessoryPermission = (android.os.IBinder.FIRST_CALL_TRANSACTION + 11); static final int TRANSACTION_hasDefaults = (android.os.IBinder.FIRST_CALL_TRANSACTION + 12); static final int TRANSACTION_clearDefaults = (android.os.IBinder.FIRST_CALL_TRANSACTION + 13); static final int TRANSACTION_setCurrentFunction = (android.os.IBinder.FIRST_CALL_TRANSACTION + 14); static final int TRANSACTION_setMassStorageBackingFile = (android.os.IBinder.FIRST_CALL_TRANSACTION + 15); static final int TRANSACTION_allowUsbDebugging = (android.os.IBinder.FIRST_CALL_TRANSACTION + 16); static final int TRANSACTION_denyUsbDebugging = (android.os.IBinder.FIRST_CALL_TRANSACTION + 17);&#125;/* Returns a list of all currently attached USB devices */public void getDeviceList(android.os.Bundle devices) throws android.os.RemoteException;/* * Returns a file descriptor for communicating with the USB device. The * native fd can be passed to usb_device_new() in libusbhost. */public android.os.ParcelFileDescriptor openDevice( java.lang.String deviceName) throws android.os.RemoteException;/* Returns the currently attached USB accessory */public android.hardware.usb.UsbAccessory getCurrentAccessory() throws android.os.RemoteException;/* * Returns a file descriptor for communicating with the USB accessory. This * file descriptor can be used with standard Java file operations. */public android.os.ParcelFileDescriptor openAccessory( android.hardware.usb.UsbAccessory accessory) throws android.os.RemoteException;/* * Sets the default package for a USB device (or clears it if the package * name is null) */public void setDevicePackage(android.hardware.usb.UsbDevice device, java.lang.String packageName, int userId) throws android.os.RemoteException;/* * Sets the default package for a USB accessory (or clears it if the package * name is null) */public void setAccessoryPackage( android.hardware.usb.UsbAccessory accessory, java.lang.String packageName, int userId) throws android.os.RemoteException;/* Returns true if the caller has permission to access the device. */public boolean hasDevicePermission(android.hardware.usb.UsbDevice device) throws android.os.RemoteException;/* Returns true if the caller has permission to access the accessory. */public boolean hasAccessoryPermission( android.hardware.usb.UsbAccessory accessory) throws android.os.RemoteException;/* * Requests permission for the given package to access the device. Will * display a system dialog to query the user if permission had not already * been given. */public void requestDevicePermission(android.hardware.usb.UsbDevice device, java.lang.String packageName, android.app.PendingIntent pi) throws android.os.RemoteException;/* * Requests permission for the given package to access the accessory. Will * display a system dialog to query the user if permission had not already * been given. Result is returned via pi. */public void requestAccessoryPermission( android.hardware.usb.UsbAccessory accessory, java.lang.String packageName, android.app.PendingIntent pi) throws android.os.RemoteException;/* Grants permission for the given UID to access the device */public void grantDevicePermission(android.hardware.usb.UsbDevice device, int uid) throws android.os.RemoteException;/* Grants permission for the given UID to access the accessory */public void grantAccessoryPermission( android.hardware.usb.UsbAccessory accessory, int uid) throws android.os.RemoteException;/* * Returns true if the USB manager has default preferences or permissions * for the package */public boolean hasDefaults(java.lang.String packageName, int userId) throws android.os.RemoteException;/* Clears default preferences and permissions for the package */public void clearDefaults(java.lang.String packageName, int userId) throws android.os.RemoteException;/* Sets the current USB function. */public void setCurrentFunction(java.lang.String function, boolean makeDefault) throws android.os.RemoteException;/* Sets the file path for USB mass storage backing file. */public void setMassStorageBackingFile(java.lang.String path) throws android.os.RemoteException;/* * Allow USB debugging from the attached host. If alwaysAllow is true, add * the the public key to list of host keys that the user has approved. */public void allowUsbDebugging(boolean alwaysAllow, java.lang.String publicKey) throws android.os.RemoteException;/* Deny USB debugging from the attached host */public void denyUsbDebugging() throws android.os.RemoteException;&#125; 增加包名为android.os的包，并且添加ServiceManager.java文件。文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package android.os; import java.util.Map; public final class ServiceManager &#123; public static IBinder getService(String name) &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; /** * Place a new @a service called @a name into the service manager. * * @param name * the name of the new service * @param service * the service object */ public static void addService(String name, IBinder service) &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; /** * Retrieve an existing service called @a name from the service manager. * Non-blocking. */ public static IBinder checkService(String name) &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; public static String[] listServices() throws RemoteException &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; /** * This is only intended to be called when the process is first being * brought up and bound by the activity manager. There is only one thread in * the process at that time, so no locking is done. * * @param cache * the cache of service references * @hide */ public static void initServiceCache(Map&lt;String, IBinder&gt; cache) &#123; throw new RuntimeException(&quot;Stub!&quot;); &#125; &#125; 新建一个广播接收类，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.HashMap;import java.util.Iterator;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.pm.ApplicationInfo;import android.content.pm.PackageManager;import android.hardware.usb.IUsbManager;import android.hardware.usb.UsbDevice;import android.hardware.usb.UsbManager;import android.os.IBinder;import android.os.ServiceManager;public class LaunchReceiver extends BroadcastReceiver&#123; @SuppressLint(&quot;NewApi&quot;) public void onReceive( Context context, Intent intent ) &#123; String action = intent.getAction(); if( action != null &amp;&amp; action.equals( Intent.ACTION_BOOT_COMPLETED ) ) &#123; try &#123; PackageManager pm = context.getPackageManager(); ApplicationInfo ai = pm.getApplicationInfo( YOUR_APP_PACKAGE_NAMESPACE, 0 ); if( ai != null ) &#123; UsbManager manager = (UsbManager) context.getSystemService( Context.USB_SERVICE ); IBinder b = ServiceManager.getService( Context.USB_SERVICE ); IUsbManager service = IUsbManager.Stub.asInterface( b ); HashMap&lt;String, UsbDevice&gt; deviceList = manager.getDeviceList(); Iterator&lt;UsbDevice&gt; deviceIterator = deviceList.values().iterator(); while( deviceIterator.hasNext() ) &#123; UsbDevice device = deviceIterator.next(); if( device.getVendorId() == 0x4292 )//usb设备的vid（厂家提供） &#123; service.grantDevicePermission( device, ai.uid ); service.setDevicePackage( device, YOUR_APP_PACKAGE_NAMESPACE ,ai.uid); &#125; &#125; &#125; &#125; catch( Exception e ) &#123; //trace( e.toString() ); &#125; &#125; &#125;&#125; 将应用拷贝在/system/app下面，点击安装，成为系统应用。将APK拷贝到/system/app的方法是： 1234#adb shell # mount -o remount,rw -t ext4 /dev/block/mtdblock3 /system // 让分区可写。 //windows回到命令提示符下 &gt;adb push xxx.apk /system/app/ 当然，不要忘了在AndroidManifest.xml文件中添加权限： 1&lt;uses-permission android:name=&quot;android.permission.MANAGE_USB&quot; /&gt; 12345&lt;intent-filter&gt; &lt;action android:name=&quot;android.hardware.usb.action.USB_DEVICE_ATTACHED&quot; /&gt;&lt;/intent-filter&gt;&lt;meta-data android:name=&quot;android.hardware.usb.action.USB_DEVICE_ATTACHED&quot; android:resource=&quot;@xml/device_filter&quot;/&gt; 其中device_filter.xml文件包含usb读卡器的vid和pid: 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;!-- 以下内容的 vendor-id、product-id就是USB的vid和pid了--&gt; &lt;usb-device vendor-id=&quot;4292&quot; product-id=&quot;1234&quot;/&gt; &lt;/resources&gt; 在步骤3中的广播接受类中可以指定此vid。 至此，我们可以不修改源码，在应用层绕过usb对话框。经测试，在安卓5.1.1版本成功！如果其他版本的系统无效，可能需要根据对应版本的系统源码，修改步骤1、2的代码。 参考 bypass android usb host permission confirmation dialog 绕过android usb主机permision确认对话框 Android绕过usb主机permision确认对话框framework修改方案 Android定制：去掉USB权限弹窗]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓使用zbar扫描二维码]]></title>
    <url>%2F2018%2F06%2F03%2F%E5%AE%89%E5%8D%93%E4%BD%BF%E7%94%A8zbar%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近需要利用安卓开发板连接USB摄像头进行二维码扫描，一般大家都使用的是zxing和zbar两个开源库，但一般zbar比zxing快，而效果差不多，所以选择使用的是zbar。 使用刚接触安卓不久，没有仔细研究jni编译，使用的是网上直接下载的Jar包和so文件，放入libs目录下，可以直接引用。可以在我的github地址下载。如果想自己编译，参考二维码识别之Android完整编译Zbar。 图像数据格式网上基本上使用的是安卓自带的摄像头，可以直接在回调函数获取数据： 12345678910PreviewCallback previewCb = new PreviewCallback() &#123; public void onPreviewFrame(byte[] data, Camera camera) &#123; Camera.Parameters parameters = camera.getParameters(); Size size = parameters.getPreviewSize(); Image barcode = new Image(size.width, size.height, &quot;Y800&quot;); barcode.setData(data); int result = scanner.scanImage(barcode); &#125;&#125; data就是每一帧图像的像素数据，YUV格式，对应zbar的”Y800”格式（实际使用发现二值图像素数据也可以）。 但是项目中我使用的是USB摄像头，根据网上找的USB摄像头例程SimpleWebCam获取到的是每一帧的Bitmap，然后我再从中获取图像处理中更常用的BGR像素数据。当然可以在USB摄像头例程中通过jni获取YUV数据，这样速度肯定更快。 zbar怎样使用BGR数据呢？百度搜索没有找到答案，然而用英文google第一条就找到答案（所以技术问题还是要多用google，远离百度）。zbar只支持扫描”Y800”和‘GRAY“格式的图像，但是Image可以导入多种类型的数据，最后转成支持的格式即可： 123Image barcode = new Image(width, height, &quot;BGR3&quot;); //一般图像处理习惯使用BGR三通道数据barcode.setData(data);int result = scanner.scanImage(barcode.convert(&quot;Y800&quot;)); 再比如使用安卓API直接获取”ARGB”格式数据： 12int[] data = new int[width*height];bmp.getPixels(data, 0, width, 0, 0, width, height); 123Image barcode = new Image(width, height, &quot;ARGB&quot;);barcode.setData(data);int result = scanner.scanImage(barcode.convert(&quot;Y800&quot;)); 检测效果一开始发现二维码识别效率不高，更改了参数后识别效果明显提升： 1234567//网上大家使用的参数//scanner.setConfig(0, Config.X_DENSITY, 3);//scanner.setConfig(0, Config.Y_DENSITY, 3);//效果提升的参数scanner.setConfig(0, Config.ENABLE, 0);scanner.setConfig(Symbol.QRCODE, Config.ENABLE, 1); 更改后的参数只识别二维码，不识别条形码。 参考 二维码识别之Android完整编译Zbar Android开源库之使用ZBar开源库实现二维码功能]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像相似度计算]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%9B%BE%E5%83%8F%E7%9B%B8%E4%BC%BC%E5%BA%A6%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[图像相似度计算主要有两方面应用： 用于计算机视觉中的检测跟踪中目标位置的获取，根据已有模板在图像中找到一个与之最接近的区域。然后一直跟着。已有的一些算法比如BlobTracking，Meanshift，Camshift，粒子滤波等等也都是需要这方面的理论去支撑。 基于图像内容的图像检索，也就是以图搜图。 图像相似度计算常见算法 PSNR峰值信噪比 PSNR是最普遍和使用最为广泛的一种图像客观评价指标，然而它是基于对应像素点间的误差，即基于误差敏感的图像质量评价。 优点：速度快。 缺点：由于并未考虑到人眼的视觉特性（人眼对空间频率较低的对比差异敏感度较高，人眼对亮度对比差异的敏感度较色度高，人眼对一个区域的感知结果会受到其周围邻近区域的影响等），因而经常出现评价结果与人的主观感觉不一致的情况。 感知哈希算法 感知哈希算法(perceptual hash algorithm)，它的作用是对每张图像生成一个“指纹”(fingerprint)字符串，然后比较不同图像的指纹。结果越接近，就说明图像越相似。 一般是利用像素点与平均像素值的大小生成一个二进制指纹。 优点：速度快。 缺点：受均值影响太大；效果一般。 计算特征点 主要是通过检测如FAST、SURF、SIFT、ORB以及Harris角点等特征点，如果相似特征点较多，则认为两张图片相似。 优点：具有旋转、尺度等不变性，较准确。 缺点：计算量大。 直方图匹配 分别计算两幅图像的直方图，然后计算它们的相关系数（实际上也就是两个向量的差异）。 优点：计算简单。 缺点： 直方图反映的只是像素的概率分布，与像素的位置无关，然而两张图片内容差别较大，灰度概率分布差异很小也是有可能的。（可以利用分块进行改进。） 对光照敏感。 数学上的矩阵分解 图像本身就是一个矩阵，可以依靠数学上矩阵分解的一些知识来获取矩阵中一些代表这个矩阵元素值和分布的一些鲁棒性特征来对图像的相似度进行计算。 最常用的一般是SVD分解和NMF分解。有人使用SVD+NMF结合取得了不错的效果。 基于局部纹理特征的图像相似度计算上述方法基本只能达到粗糙的效果，很多时候两幅整体相似但细节差异较大的图可能判定相似，难以得到精确的结果。 LBP（Local Binary Pattern，局部二值模式）是一种用来描述图像局部纹理特征的算子；它具有旋转不变性和灰度不变性等显著的优点。 原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素 点的位置被标记为1，否则为0。这样，3*3邻域内的8个点经比较可产生8位二进制数（通常转换为十进制数即LBP码，共256种），即得到该窗口中心像 素点的LBP值，并用这个值来反映该区域的纹理信息。 LBP特征跟位置信息是紧密相关的。直接对两幅图片提取LBP，并进行判别分析的话，会因为“位置没有 对准”而产生很大的误差。可以用分块来解决这个问题。 对LBP特征向量进行提取的步骤： 将图片缩小尺寸，去除部分高频和细节； 将检测窗口划分为若干个小区域（cell）； 对于每个cell中的一个像素，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0。这样，3*3邻域内的8个点经比较可产生8位二进制数，即得到该窗口中心像素点的LBP值； 计算每个cell的直方图，即每个数字（假定是十进制数LBP值）出现的频率；然后对该直方图进行归一化处理。 将得到的每个cell的统计直方图进行连接成为一个特征向量，也就是整幅图的LBP纹理特征向量； 通过一定的度量方法（如皮尔逊相关系数）比较两张图片的LBP特征向量的相似度。 上述其实就是基于LBP的人脸识别算法，在图像相似度计算的实际应用中有几点需要注意： 直接比较周围像素值与中心像素值的大小，可能会太灵敏，可设定一个阈值（一般为1~2），像素差与阈值进行比较。 图片缩放的大小、子块大小、数量都对结果有着直接的影响，可以根据实际效果选择合适的参数。 实际应用中发现对缩放后的图片进行3*3的模糊滤波，能实现更好的效果。 参考 OpenCV进行图像相似度对比的几种办法 图像相似度计算 图像相似度测量与模板匹配总结 图像特征提取三大法宝：HOG特征，LBP特征，Haar特征]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vultr搭建ssr服务器及bbr加速教程]]></title>
    <url>%2F2018%2F03%2F22%2Fvultr%E6%90%AD%E5%BB%BAssr%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8Abbr%E5%8A%A0%E9%80%9F%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[科学上网的方式很多，最稳定安全可靠的当属自建vps服务器。这里记录自己搭建vps的全过程，以供参考。 vps商家选择首先，有信用卡的同学，可以选择谷歌云或亚马逊aws，绑定信用卡都可以免费使用一年，配置高，速度杠杠的。可以自行搜索相关教程。 vps和云服务器的区别： VPS的虚拟机是一台物理服务器虚拟出的多个独立服务器，云服务器是运行在一个物理服务器集群上的。云服务器可以动态平衡负载，弹性调整配置，而且稳定性更高。 没信用卡就只能其他vps运营商了，目前速度和服务都不错的有搬瓦工、Vultr、Linode和DigitalOcean等，很多很便宜的或用的人很少的就不用考虑了。 搬瓦工低价套餐现在基本买不到，最便宜的要$49.99一年，而且换IP要收费几美元，要是ip被ban就很亏。其他三家貌似都差不多，vultr优惠较多，所以我选择vultr。 购买VPSvultr注册地址：https://www.vultr.com/?ref=7368419 ，可以使用paypal或支付宝付款。 vultr是折算成小时计费，服务一直部署着就一直计费。不用的话服务器需要destroy删除才停止计费，仅仅stop还是会计费。删除再新开服务器只需要$0.01。 每月有流量限制，超出额外收费。北美和西欧地区的服务器超出流量后，多出的部分收费为0.01美元/G。新加坡和日本东京（日本）为0.025美元/G，悉尼（澳大利亚）为0.05美元/G。把vultr服务器删掉，开通新的服务器，流量会从0开始重新计算。 vultr目前来说对国内最友好的机房就是日本东京机房和美国洛杉矶机房，其他机房不值得选购。 注意系统类型选择centos6，entos7默认的防火墙可能会干扰ssr的正常连接。 部署好之后ping服务器的ip，所以发现ping不通ip删除再部署，用新的ip重新测一下。一般延迟100多毫秒还行。 部署VPS下载Xshell软件远程连接vps，连接成功后输入以下指令安装ssr： 12yum -y install wgetwget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 设置好端口和密码，其他选项可以用默认设置。 bbr加速加速方式有bbr、锐速、kcptun等，这里选择谷歌的bbr。加速后速度提升明显，youtube 1080p无压力。 输入以下命令： 1234yum -y install wgetwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 完成操作后重启服务器，至此服务端配置完成。 ssr客户端安装ssr客户端地址：https://github.com/shadowsocksr-backup，各版本都有。 参考 自建ss服务器教程 VPS 艹机狂魔]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TODO 单页应用笔记]]></title>
    <url>%2F2017%2F11%2F22%2FTODO-%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前段时间花了很多业余时间，完成了一个 TODO 页面，详见这里。以下是一些总结。 HTML与数据交互一开始做这个todo应用时，是使用纯dom操作的，再加上使用的是原生js，那叫一个痛苦，想起用jQuery的幸福时光了（原谅小白只会jQuery）。但写了一些，发现太难操作数据了，代码耦合非常严重，查到张鑫旭大神的博客js面向数据编程(DOP)一点分享，用HTML模板拼接，批量刷新，顿时想起还有这种操作，于是重写。dom操作对于很小的页面修改还可以，对于频繁的页面操作，还是使用HTML模板方便太多（不过听说现在都是使用什么双向数据绑定了，回头了解下）。 更新：上述HTML模板其实是伪模板，HTML耦合在js代码中，不利于修改，数据的应用也不具有规律性，很麻烦，详见张鑫旭后来写的另一篇文章基于HTML模板和JSON数据的JavaScript交互。 数据结构的设计和存储数据使用JSON结构化，使用了数据库的思想。 本地存储使用localStorage。 存储：localStorage.setItem(&#39;item&#39;, content);，一般都是存储字符串，所以需要将对象序列化：JSON.stringify(obj)。 取出：localStorage.getItem(&#39;item&#39;)，取出的仍然是字符串，需要反序列化：JSON.parse(str)。 调试阶段，chrome中本地页面可能无法使用localStroge，在设置中启用就可以了。 对话框模态框：对话框分为模态类型（modal）和非模态类型。如果打开的是模态窗口，那么你就只能对当前此窗口进行操作，而普通窗口则可以进行任意切换。alert()、confirm()、prompt()都属于模态框。 半透明遮罩层呈现模态框：以前写了个demo见这里，需要注意的是，半透明遮罩不要使用opacity（半透明遮罩上还要显示其他内容的话），而使用background-color: rgba(0, 0, 0, 0.5);,否则其上的内容也会是半透明的。 confirm(message)用于显示一个带有指定消息和 OK 及取消按钮的对话框。如果用户点击确定按钮，则 confirm() 返回 true。如果点击取消按钮，则 confirm() 返回 false。prompt(text,defaultText)用于显示可提示用户进行输入的对话框。如果用户单击提示框的取消按钮，则返回 null。如果用户单击确认按钮，则返回输入字段当前显示的文本。 表单相关元素js获取select标签选中的值 123456var obj = document.getElementById(”testSelect”); //定位selectvar index = obj.selectedIndex; // 选中索引var text = obj.options[index].text; // 选中option的文本var value = obj.options[index].value; // 选中option的value属性值//或var value = obj.value; //单选下拉列表框对象的value属性值就是选中项的value值 获取和设置textarea标签的值，dom中，只能用的value属性，不能用innerHTML。但html中没有value属性，所以html中设置值只能用标签包括。 textarea设置成最大化样式： 123456textarea &#123; width: 100%; height: 100%; resize: none; outline: none;&#125; &lt;input id=&quot;meeting&quot; type=&quot;date&quot; value=&quot;2014-01-13&quot;/&gt;,type实际上是可以为“date”、“week”、“month”、“time”、“datetime”和“datetime-local”。 两种立即执行函数1234567(function() &#123;//...&#125;( args ) );//------------------------------------(function() &#123;//...&#125;)( args ); 浮动元素垂直居中父元素设置 12display: table-cell;vertical-align: middle; 其实这个页面并没有什么复杂的东西，就是其中数据结构一开始设计的不够好，后面参考了这里，表示感谢。这么个简单的东西我还是花了大量时间，暴露出来很多基础的问题，还是之前太浮躁，没有打牢基础。接下来需要重构、工程化以及适配移动端，要学的东西太多了。路漫漫其修远兮，坚持就是胜利。 更新： require.js重构事件代理当使用html模板更新页面，需要重新绑定事件，这样非常麻烦，一种简单的方法就是使用事件代理：模板的容器元素监听事件，当点击某个元素，事件会冒泡到容器元素触发相应事件，然后通过listener.call(target, event)触发目标元素的事件。因为指定了目标元素，所以其子元素的事件不会触发，这时只能手动指定子元素了。 12345678910111213var delegateEventByTagName = function (element, tag, eventName, listener) &#123; addEvent(element, eventName, function (e) &#123; var event = e || window.event; var target = event.target || event.srcElement; if (target.tagName.toUpperCase() === tag.toUpperCase()) &#123; listener.call(target, event); &#125; else if (target.parentNode.tagName.toUpperCase() === tag.toUpperCase()) &#123; //子元素冒泡一层 listener.call(target.parentNode, event); &#125; &#125;);&#125;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负边距]]></title>
    <url>%2F2017%2F09%2F20%2F%E8%B4%9F%E8%BE%B9%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[以前元素负边距用得较少，一般是使用绝对定位对于宽高不固定的元素居中时才使用。昨天学习圣杯布局的时候，发现负边距的功能很强大，于是总结如下。 负边距在普通static文档流中的作用 在普通文档流中，元素在top/left使用负边距时，它把元素向这个特定的方向移动。 但是当你将负边距设置为相对bottom/right时，它并不会把元素向下或右拉，相反，它会把后面的元素往里面拉，从而覆盖自己。 如果宽度没有设置，左右负边距会把元素向两个方向拉以增加宽度。在这里margin的作用相当于padding。 负边距对浮动元素的影响 如果对一个浮动的元素使用负边距，它会产生一个空白，负的边距部分不占空间，其他元素就可以覆盖这一部分。 最后一个元素的负边距产生的空白可以叠加到其他元素上，这就导致最后一个浮动元素宽度没有受到影响一样。如果两个元素都使用了左浮动并且设置负的margin-right，后面的元素会把前面的元素看成宽度缩小（所以会覆盖一部分），但是有趣的是后面的元素并不会有任何变化，而是依然保持原先的宽度。 如果负边距和宽度一样大的话，它就会被完全覆盖掉。 负边距对绝对定位元素的影响使元素反方向移动对应距离。 参考[译] 负边距详解-segmentfault]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏式布局]]></title>
    <url>%2F2017%2F09%2F19%2F%E4%B8%89%E6%A0%8F%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[以前常听说圣杯布局和双飞翼布局，并没有认真研究过，但实际上，他们只是三栏式布局的两种布局方法而已。本文将介绍三栏式布局的几种思路。 初级方法页面布局常常要用到左右固定，中间自适应的三栏式布局，以前使用的是下面两种方法： 方法一：左右设置固定宽度，然后使用绝对定位position:absolute及left、right属性定位左右盒子位置,最后根据左右宽度设置中间部分的margin。 12345678910111213141516171819202122232425.container &#123; height:200px; overflow:hidden;&#125;.left &#123; width: 200px; height: 200px; position: absolute; left: 0; top: 40px; background-color: #E79F6D;&#125;.middle &#123; height: 200px; margin: 0 210px 0 200px; background-color: #D6D6D6;.right &#123; width: 210px; height: 200px; position: absolute; right: 0; top: 40px; background-color: #77BBDD;&#125; 方法二：左右设置固定宽度，分别左右浮动;根据左右宽设置中间部分的margin；设置父元素overflow:hidden；注意采用这种方法时，html布局上中间部分必须放在最后，即左右中的顺序,这是因为中间不是浮动的，需要单独占行。 123456789101112131415161718192021.container &#123; height:200px; overflow:hidden;&#125;.left &#123; width: 200px; height: 200px; float: left; background-color: #E79F6D;&#125;.right &#123; width: 210px; height: 200px; float: right; background-color: #77BBDD;&#125;.middle &#123; height: 200px; margin: 0 210px 0 200px; background-color: #D6D6D6;&#125; 但是，实际产品中往往需要中间部分最先渲染，也就是“重要的内容先加载”，这种结构会更好一些，所以我们需要中左右的布局顺序，这种情况有两种经典的实现方式：圣杯布局和双飞翼布局。 圣杯布局下面我们按照常规思路来一步步实现圣杯布局：原始布局HTML结构： 1234567&lt;header&gt;Header&lt;/header&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;中间弹性区&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左边栏&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边栏&lt;/div&gt;&lt;/div&gt;&lt;footer&gt;Footer&lt;/footer&gt; 每个盒子的样式： 1234567891011121314151617181920212223242526272829303132header &#123; width: 100%; height: 40px; background-color: #aaa;&#125;.container &#123; overflow:hidden;&#125;.middle &#123; width: 100%; height: 200px; float:left; background-color: #D6D6D6;&#125;.left &#123; width: 200px; height: 200px; float:left; background-color: #E79F6D;&#125;.right &#123; width: 210px; height: 200px; float:left; background-color: #77BBDD;&#125;footer &#123; width: 100%; height: 30px; clear: both; background-color: #666;&#125; 问题：此时三栏并没有在父元素的一行显示，因为中间盒子我们给了百分之百的宽度，所以左右两个盒会被挤下来。 这时需要让左右两边的盒子上去，可以通过负边距实现。设置左边盒子的左边距为负的container的宽度，即.left {margin-left:-100%;}。设置右边的盒子其左边距为负的自己的宽度，也就是.right {margin-left：-200px;}。问题：此时中间盒子里的内容会被左右盒子给压住一部分。 利用父级元素设置左右内边距的值，把父级的盒子往中间挤。.container{ padding: 0 200px 0 200px;}。问题：左右盒子都随中间盒子往中间挤了，需要将左右的恢复到原来的位置。 给左右两个盒子加相对定位，左右两个盒子就可以设置left和right值。.left{ position: relative; left: -200px;},.right{position: relative;right: -210px;}。至此，圣杯布局完成。 缺点：并没有实现等高布局；使用了相对定位，扩展性不好。 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; header &#123; width: 100%; height: 40px; background-color: #aaa; &#125; .container &#123; height:200px; padding: 0 210px 0 200px; overflow:hidden; &#125; .middle &#123; width: 100%; height: 200px; float:left; background-color: #D6D6D6; &#125; .left &#123; width: 200px; height: 200px; margin-left:-100%; float:left; position: relative; left: -200px; background-color: #E79F6D; &#125; .right &#123; width: 210px; height: 200px; margin-left: -210px; float:left; position: relative; right: -210px; background-color: #77BBDD; &#125; footer &#123; width: 100%; height: 30px; background-color: #666; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;Header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;中间弹性区&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左边栏&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边栏&lt;/div&gt; &lt;/div&gt; &lt;footer&gt;Footer&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局双飞翼布局可以看成是对圣杯布局的改进。前两步都是一样的，重要的是第三步，在前两步的完成后已经形成同行排列，只不过中间栏里面的内容被遮挡。为解决这个问题，圣杯布局的第三步是给container容器添加padding属性，而双飞翼布局是为main里面的内容再加一个div，让main的内容包含在内层div里，设置内层div的margin-left和margin-right为左右两栏div留出位置。 优点：比圣杯布局少用了多个属性，更直接和简洁。缺点：并没有实现等高布局，增加了html结构。 123456789&lt;header&gt;Header&lt;/header&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt; &lt;div class=&quot;middle-inner&quot;&gt;中间弹性区&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左边栏&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边栏&lt;/div&gt;&lt;/div&gt;&lt;footer&gt;Footer&lt;/footer&gt; 1234567891011121314151617181920212223242526272829303132333435363738header &#123; width: 100%; height: 40px; background-color: #aaa;&#125;.container &#123; height:200px; overflow:hidden;&#125;.middle &#123; width: 100%; height: 200px; float:left; background-color: #D6D6D6;&#125;.left &#123; width: 200px; height: 200px; margin-left:-100%; float:left; background-color: #E79F6D;&#125;.right &#123; width: 210px; height: 200px; margin-left: -210px; float:left; background-color: #77BBDD;&#125;.middle-inner &#123; margin: 0 210px 0 200px;&#125;footer &#123; width: 100%; height: 30px; clear: both; background-color: #666;&#125; 绝对定位设置子元素的top:0;bottom:0;使得所有子元素的高度都和父元素的高度相同，实现等高效果。缺点: 需要为容器元素设置高度，扩展性较差。 1234567&lt;header&gt;Header&lt;/header&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot;&gt;中间弹性区&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左边栏&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边栏&lt;/div&gt; &lt;/div&gt;&lt;footer&gt;Footer&lt;/footer&gt; 1234567891011121314151617181920212223242526272829303132333435 header &#123; width: 100%; height: 40px; background-color: #aaa;&#125;.container &#123; height: 200px; position: relative;&#125;.middle,.left,.right &#123; position: absolute; top: 0; bottom: 0;&#125;.middle &#123; left: 200px; right: 210px; background-color: #D6D6D6;&#125;.left &#123; width: 200px; background-color: #E79F6D;&#125;.right &#123; width: 210px; right: 0; background-color: #77BBDD;&#125;footer &#123; width: 100%; height: 30px; background-color: #666;&#125; flex布局flex中的伸缩项目默认都拉伸为父元素的高度，可实现等高效果。通过改变伸缩项目的order，可以实现元素顺序调换的效果。设置中间盒子flex: 1可实现伸缩。flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间。 缺点: 兼容性不高。 123456789101112131415161718192021222324252627282930header &#123; width: 100%; height: 40px; background-color: #aaa;&#125;.container &#123; display: flex;&#125;.middle &#123; order: 1; flex: 1; height: 200px; background-color: #D6D6D6;&#125;.left &#123; width: 200px; height: 200px; background-color: #E79F6D;&#125;.right &#123; order: 2; width: 210px; height: 200px; background-color: #77BBDD;&#125;footer &#123; width: 100%; height: 30px; background-color: #666;&#125; 总结各种方法各有优缺点，个人更倾向于使用强大简洁的flex布局，让古董浏览器见鬼去吧。 后记最近在找一些小项目练手，在github上看到很多如我一样的初学者，他们将做项目中遇到的每个问题，无论大小，分析根源，记录在博客中，他们认真细致的态度真让我自愧不如，甚至惊叹。现在他们很多是BAT的员工了，我想这是助他们进入大公司的重要特质之一。像我就是很多时候遇到问题，没有及时记录，或者问题没有分析透彻，似懂非懂，结果下次遇到还是不会。深入思考，弄清每一处细节，比似懂非懂多学几个知识点要重要得多。 参考圣杯布局和双飞翼布局-简书三栏式布局(所谓的圣杯和双飞翼)-博客园]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript日期选择组件的实现]]></title>
    <url>%2F2017%2F06%2F19%2FJavaScript%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[实际网页开发中经常要用到各种日期组件，这里通过原生HTML/CSS/JavaScript完成一个日期选择器（datepicker）组件的开发。 效果如下： 基本功能： 点击输入框出现日历。 点击日期，输入框内容为选择的日期，日历收起。 点击左右箭头翻月。 主要工作包括HTML静态结构的编写、日历数据的获取、组件的渲染以及组件事件的处理。 HTML结构日历部分主要分为两部分：head区域（年月显示和月份切换）、body区域（星期和日期）。而body区域由table布局，星期为thead,日期为tbody。因为一个月最多可能跨越6周，所以tbody为42个单元格。样式编写在此省略。 日历数据的获取获取一个月（日历页面）的所有数据的过程如下： 一个月的天数1/3/5/7/8/10/12月有31天，平年2月28天，闰年2月29天，其余月份30天。可以写一个函数根据年月获取某年某月有多少天。还有一种更简单的方法，本月（month-1）的天数=本月最后一天日期=下月（month）的第0天日期。同理，上月的天数=上月最后一天=本月的第0天。 1234//下月的第0天var curMonthLastDay = new Date(year, month, 0);//本月的天数-本月最后一天var curMonthDayNum = curMonthLastDay.getDate(); 需要显示的上一月的天数星期按周日到周六排列，那么需 要显示的上一月的天数=本月的第一天的星期数（0-6）。 需要显示的下一月的天数需要显示的下一月的天数=42-本月的天数-上月显示的天数。 根据以上数据即可获取一个日历页面的数据，保存在一个数组中，为下一步渲染提供数据。 生成TML结构日历表格的结构复杂、内容变化频繁，我们采用动态生成DOM元素的方法，最后添加到页面。这一过程也简单，使用字符串拼接标签与上步获得的数据，生成HTML字符串。 渲染显示将日历包含在一个wrapper容器中，将HTML结构添加在wrapper中，最后在body上添加wrapper。 事件处理因为HTML内容是动态生成与删除，每个表格添加事件太麻烦，因此利用事件冒泡，将点击事件添加到wrapper容器。月份切换同理。 组件初始化 定位在使用时，只需要添加一个输入框，输入框可能出现在任何位置，为了让日历固定邻接输入框下方，需要在初始化时通过offsetLeft与offsetTop获取输入框的位置，以此使用绝对定位调整日历容器的位置。 显示与隐藏使用wrapper.classList.add()与wrapper.classList.remove()添加或移除类名控制日历的显示与隐藏。 月份切换事件处理函数中获取相应月份的数据，重新渲染显示。 日期的点击选择要在点击表格元素时获取对应日期，可以获取对应td的innerHtml，但这样当月显示的上月和下月日期获取会有错误。因此，在生成HTML结构时，为每个日期td添加自定义属性，存储准确的日期，通过target.dataset.propName可获取自定义data-propName属性的值。 上下月日期显示灰色生成HTML内容时为上下月添加控制样式的类即可。 组件化思想为了模块不污染外部环境，将所有JS代码包裹在一个立即执行的匿名函数(function () {})()中，在函数中定义一个对象var datepicker = {};，唯一暴露给外界的对象只有该对象：window.datepicker = datepicker;。组件的容器类名可以取一个独特且比较长的名字，避免与外界产生冲突：ui-datepicker-wrapper，所有组件内部元素名称通过级联选择器包含在这个选择器内。 代码预览地址代码地址 参考DatePicker组件开发 - 慕课网]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯CSS实现Tab选项卡]]></title>
    <url>%2F2017%2F04%2F13%2F%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0Tab%E9%80%89%E9%A1%B9%E5%8D%A1%2F</url>
    <content type="text"><![CDATA[Tab选项卡很常见，一般都是通过js或jq实现，更灵活强大，但有时需求简单只用CSS也是可以实现的，也更简单方便。这里介绍两种方案。 通过a标签的锚点实现这里又有两种具体实现方法： 纯锚点原理设置锚点链接指向相应div，将所有Tab指向的div放到一个固定宽高的容器里，并设置容器overflow:hidden，并且每个Tab页面的高度与容器保持一致。当点击锚点链接时，锚点对应的内容就会自动跳到可视范围以内。缺点：当CSS缺失的情况下无法清晰的阅读内容。 代码html 123456789101112&lt;div id="box"&gt; &lt;div id="tab-nav"&gt; &lt;a href="#t1"&gt;tab1&lt;/a&gt; &lt;a href="#t2"&gt;tab2&lt;/a&gt; &lt;a href="#t3"&gt;tab3&lt;/a&gt; &lt;/div&gt; &lt;div id="tab-content"&gt; &lt;div id="t1"&gt;page1&lt;/div&gt; &lt;div id="t2"&gt;page2&lt;/div&gt; &lt;div id="t3"&gt;page3&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; css 1234567891011121314151617#box &#123; display: inline-block;&#125;#tab-nav a &#123; text-decoration:none; border:1px solid #999; &#125;#tab-content &#123; width:150px; height:100px; border:1px solid #999; overflow:hidden;&#125;#tab-content &gt; div &#123; width:100%; height:100px;&#125; DEMO预览地址代码地址 锚点 + :target原理可以通过点击锚链接触发指定元素的伪类:target，因此，可以将Tab页面内容隐藏，在:target伪类中设置Tab页面可见。这样在缺少CSS时依然可以清晰的阅读内容。html内容同上。 代码css 1234567891011121314151617181920#box &#123; display: inline-block;&#125;#tab-nav a &#123; text-decoration:none; border:1px solid #999; &#125;#tab-content &#123; width:150px; height:100px; border:1px solid #999; &#125;#tab-content &gt; div &#123; display: none;&#125;#tab-content &gt; div:target &#123; display: inline-block; width:100%; height:100px;&#125; DEMO预览地址代码地址 通过radio及:checked伪类实现原理隐藏所有Tab内容及input,显示label并关联相应input，当点击相应label选中radio,通过radio的:checked伪类显示相应Tab内容。 代码html 12345678910111213141516171819&lt;div class="box"&gt; &lt;ul&gt; &lt;li&gt; &lt;input type="radio" id="item1" name="item" checked&gt;&lt;/input&gt; &lt;label for="item1"&gt;tab1&lt;/label&gt; &lt;div class="table-container"&gt;page1&lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="radio" id="item2" name="item"&gt;&lt;/input&gt; &lt;label for="item2"&gt;tab2&lt;/label&gt; &lt;div class="table-container"&gt;page2&lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="radio" id="item3" name="item"&gt;&lt;/input&gt; &lt;label for="item3"&gt;tab3&lt;/label&gt; &lt;div class="table-container"&gt;page3&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; css 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.box &#123; width: 400px; height: 370px;&#125;.box .table-container &#123; display: none; z-index: 1;&#125;.box ul &#123; position: relative; overflow: visible; height: 30px; margin: 0; padding-left: 30px;&#125;.box li &#123; display: inline-block; float: left; width: 80px; margin-right: 6px; list-style: none;&#125;.box li label &#123; display: block; width: 80px; height: 30px; border: 1px solid #fff;/*背景色*/ border-top-right-radius: 6px; border-top-left-radius: 6px; text-align: center; line-height: 30px; background-color: #f5f5f5; cursor: pointer;&#125;.box li input &#123; display: none;&#125;.box input:checked ~ label &#123; position: relative;/*设置z-index*/ border: 1px solid #ccc; border-bottom: 1px solid #fff; background-color: #fff; z-index: 2;&#125;.box input:checked ~ .table-container &#123; display: block; position: absolute; top: 31px;/*border-top与label重合*/ left: 30px; width: 340px; height: 240px; border: 1px solid #ccc;&#125; 效果 DEMO预览地址代码地址 参考css实现tab切换 - CSDN]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯CSS实现可折叠树状菜单]]></title>
    <url>%2F2017%2F04%2F07%2F%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8A%98%E5%8F%A0%E6%A0%91%E7%8A%B6%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[上一篇文章通过CSS模拟了自定义下拉列表select样式，这里介绍的CSS实现可折叠树状菜单原理也类似。 原理利用checkbox的checked值判断是否展开下级菜单。当未点击上级菜单，即checkbox未选中时，ol设置display:none隐藏；当点击上级菜单，checkbox选中，通过:checked伪类让ol展现出来。 效果 代码HTML结构 12345678910111213141516171819202122232425&lt;div class="tree-container"&gt; &lt;ol&gt; &lt;li&gt; &lt;div class="node-container"&gt; &lt;input type="checkbox" id="tree-node1" name=""&gt; &lt;label for="tree-node1"&gt;文件一&lt;/label&gt; &lt;ol&gt; &lt;li&gt; &lt;div class="node-container"&gt; &lt;input type="checkbox" id="tree-node3" name=""&gt; &lt;label for="tree-node3"&gt;文件3&lt;/label&gt; &lt;ol&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 想要增加级数只需要在li中插入node-container类及其子元素: 123456789&lt;div class="node-container"&gt; &lt;input type="checkbox" id="tree-node3" name=""&gt; &lt;label for="tree-node3"&gt;文件3&lt;/label&gt; &lt;ol&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 兼容性经测试兼容 IE10 、chrome 和现代移动浏览器。 DEMO预览地址代码地址 参考纯CSS打造可折叠树状菜单 - CSDN树形菜单（纯CSS）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯CSS模拟下拉列表select实现自定义样式]]></title>
    <url>%2F2017%2F03%2F28%2F%E7%BA%AFCSS%E6%A8%A1%E6%8B%9F%E4%B8%8B%E6%8B%89%E5%88%97%E8%A1%A8select%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[下拉列表 select 是一个 bom 元素，因此要美化它的时候仅仅依靠 css 无法实现。这里有两种方案： 通过覆盖 select 元素来实现原理：将默认的下拉列表样式清除，自定义样式，并添加一张向右对齐的小箭头图片。 1234567891011121314151617181920option &#123; background-color: #be4e48;&#125;select &#123; width: 236px; height: 36px; /*Chrome和Firefox里面的边框是不一样的，所以复写了一下*/ border: 1px solid #be4e48; /*将默认的select选择框样式清除*/ appearance:none; -moz-appearance:none; -webkit-appearance:none; /*在选择框的最右侧中间显示小箭头图片*/ background: #fff url(right_arrow.png) no-repeat right center; padding-right: 14px;&#125;/*清除ie的默认选择框样式清除，隐藏下拉箭头*/select::-ms-expand &#123; display: none; &#125; 缺点：option 样式无法修改，包括宽高，这个真的无解。 使用 radio 模拟下拉列表网上找到的一篇博客，原理很简单但对于我这样的初学者实现起来也是很麻烦。大致理解了并进行了部分修改，有点乱。 效果： 原理： 将所有 li 使用绝对定位置于 div 触发器下,设置 z-index 使 li 被遮挡， 当鼠标移上触发 hover 选择器，这时对 li 使用相对定位回到正常文档流，同时父元素高度随之增加，呈现的便是展开的 select 样式。 当鼠标点击选项，实际上是点击 radio 对应的 label,这样 radio 便被选中，通过 input:checked 选择器将 label 的 z-index 增大。 鼠标移出后各元素位置回到最初状态，显示的是 label 选项。 radio 自始至终不可见。 1.html 123456789101112131415161718192021222324&lt;fieldset class="radio-container"&gt; &lt;div class="radio-options"&gt; &lt;div class="toggle"&gt;城市&lt;/div&gt; &lt;ul&gt; &lt;li&gt; &lt;input type="radio" name="city" id="BeiJing" value="BeiJing"&gt; &lt;label for="BeiJing"&gt;&lt;span &gt;&lt;/span&gt;北京&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="radio" name="city" id="ShangHai" value="ShangHai"&gt; &lt;label for="ShangHai"&gt;&lt;span &gt;&lt;/span&gt;上海&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="radio" name="city" id="ShenZhen" value="ShenZhen"&gt; &lt;label for="ShenZhen"&gt;&lt;span &gt;&lt;/span&gt;深圳&lt;/label&gt; &lt;/li&gt; &lt;li&gt; &lt;input type="radio" name="city" id="NewYork" value="NewYork"&gt; &lt;label for="NewYork"&gt;&lt;span &gt;&lt;/span&gt;纽约&lt;/label&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/fieldset&gt; 2.css这里省略了一些 css 代码,完整的可在最后的 github 链接查看 1234567891011121314151617181920212223242526272829303132333435363738radio-container &#123; position: relative; height: 4em; /* 3em (being the max-height of the inner container) + 1em ("margin") */ &#125;.radio-container:hover &#123; z-index: 9999; &#125;.radio-options &#123; position: absolute; max-height: 3em; width: 100%; overflow: hidden; transition: 0.7s;&#125;.radio-options:hover &#123; max-height: 100em;&#125;.radio-options .toggle &#123; position: relative; cursor: pointer; padding: 0.75em; background: darkgreen; border-radius: 10px; z-index: 1; &#125;/* li are stacked at the same position as .toggle, only .toggle is visible */ .radio-options li &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; &#125; .radio-options label &#123; display: block; opacity: 0; transition: 0s; &#125; We hide the inputs, we could just use display : none, but that would not work in browsers (some mobile ones) where clicking the label does not focus the associated input. display:none在移动设备兼容性不好，改用绝对定位。 12345678910.radio-options input &#123; position: absolute; top: 0; left: 0; width: 300px; height: 3em; opacity: 0; z-index:1; cursor: pointer;&#125; 3.鼠标移上时 12345678/* li elements have a normal flow within the .radio-options container */.radio-options:hover li &#123; position: relative; &#125;.radio-options:hover label &#123; opacity: 1; transition: 0.5s; &#125; 4.选中时radio checked 但鼠标没触发时 12345678910111213.radio-options input:checked ~ label &#123; position: absolute; top: 0; left: 0; right: 0; opacity: 1;/* is above the .toggle so is visible */ z-index: 2;/* has tha same styles as .toggle */ padding: 0.75em; background: darkgreen; border-radius: 10px; &#125; 鼠标移上时 1234.radio-options:hover input:checked ~ label &#123; position: static; border-radius: 0; &#125; 以上就是纯 css 实现自定义下拉列表的方法，经测试兼容 IE10 和 chrome。移动浏览器和 IE8 的兼容性可以参考原文。 缺点：选中选项后无法自动收起，必须鼠标移出后才可以。因为 css 没有父选择器，触发 checked 选择器后无法操作 li,要解决只能借助js了。 我们看到，使用纯 css 代码很多，比较复杂。在实际项目中还是使用js或一些插件较好，否则有点得不偿失。 预览地址代码地址 参考：Css-only Alternative to the Select ElementHow to style a select dropdown with CSS only without JavaScript - stackoverflow浅谈CSS自定义下拉列表的样式 - CSDN]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用总结]]></title>
    <url>%2F2017%2F02%2F26%2Fgit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[注意git status要经常用 基本操作#把文件修改添加到暂存区git add file #一次添加多个文件用空格git add a.txt b.cpp #把所有文件修改添加到暂存区git add .git add –all #两横杠 #把暂存区的所有内容提交到当前分支git commit -m “backup_message” 日志#查看日志,不包括回退操作记录git log #查看简要日志（只有id和备注信息）git log –pretty==online #查看每一次操作，包括回退，包含id、HEAD、操作和备注信息git reflog 比较#工作区和暂存区的比较git diff file #暂存区和分支的比较git diff –cached 删除#删除本地和远程的文件git rm file #删除缓冲区文件git rm -r –cached file 回退#回退到上一个版本（HEAD^^上上个版本，HEAD~100上100个版本）git reset –hard HEAD^ #回退到指定版本git reset –hard commit_id #让文件回到最近一次commit或add的状态git checkout – file #从暂存区移除重新放回工作区git reset HEAD file 分支#创建分支git branch branch_name #创建并切换到分支git checkout -b branch_name #切换到分支git checkout branch_name #合并分支到当前分支，提示冲突后需要手动修改冲突部分内容，只保留冲突部分的一个版本，然后再add、commitgit merge branch_name #删除分支git branch -d branch_name #删除远程分支,第一种方法相当于推送本地空分支到远程git push origin :remote_branch_namegit push origin –delete remote_branch_name #非fast forward模式合并，保留历史分支合并信息git merge –no-ff -m “backup_message” branch_name 远程#显示所有关联的远程仓库git remote -v #没有本地仓库的情况下，复制远程仓库到本地git clone remote_repo_name #关联远程仓库（在远程仓库第一次创建了还没有关联时）（origin是远程库的一个别名，可自由设置）git remote add origin remote_repo_name #把远程最新代码更新合并到本地（已经建立了关联情况下）（fetch+merge）git pull origin master #从远程获取最新版本到本地，不会自动mergegit fetch origin master #比较本地的master分支和origin/master分支的差别git log -p master origin/master #合并（fetch到本地的）远程分支git merge origin/master #建立本地分支和远程分支的连接关系（这样以后就可以直接git pull，git push）git branch –set-upstream branch_name origin/branch_name #第一次向远程仓库提交代码，之后可以省略-ugit push -u origin master 标签tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起 #对最近一次commit打标签git tag tag_name #对特定commit打标签git tag commit_id tag_name #对特定commit打标签并添加说明git tag -a tag_name -m “backup_message” commit_id #查看标签信息git show tag_name #删除标签git tag -d tag_name #推送本地标签到远程git push origin tag_name #推送全部本地标签git push origin –tags 临时存储#临时存储，可以做完别的之后过来恢复git stash #查看stash记录git stash list #恢复stash，并不删除记录git stash apply #删除stashgit stash drop #恢复同时删除stash记录git stash pop 分支管理策略master分支仅用来发布版本，平时在dev分支干活修复bug，通常会创建新的bug分支修复，然后合并，手头的工作先stash添加新功能，最好新建一个feature分支，完成后合并 参考Git教程-廖雪峰的官方网站常用 Git 命令清单-阮一峰的网络日志]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github pages+hexo搭建个人博客]]></title>
    <url>%2F2017%2F02%2F26%2Fgithub-pages-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言一直想找个简洁美观又方便（支持markdown）的地方写点东西，试过博客园，CSDN，还有各种笔记，都感觉不怎么舒服。后来发现很多人推荐用github pages+hexo搭建个人博客，果然一开始见到给我的感觉就是：惊艳。于是折腾起来，其间也遇到的各种问题，最后花了一天时间，终于完成，包括各种自定义效果和第三方服务，都尝试了一遍。最后完成打开网站的那一刻，成就感爆棚有木有！ 其实也没有，因为终究还是简单的使用，要是自己能完完全全做出个博客网站那才真的有成就感。好了，搭建博客的具体步骤就不再总结，网上很多，文末给出两篇觉得比较好的，这里总结一下一些需要注意的地方。 写博客基本流程hexo new [layout] &lt;title&gt;,layout有post、page 和 draft。也可以自己在scaffolds下新建有一个layout的md文件，使用自定义layout.在source/_posts下打开对应文件。文章头部添加信息，写文章。** 注意引号后面有空格 ** 可以建立自己的文章模板，避免每次都要输入新的属性，修改scaffolds下的post.md即可.hexo generatehexo server http://localhost:4000 预览hexo deploy 部署 文章修改修改完直接刷新localhost就能看到效果。有时候修改了没生效，尝试hexo clean或删除public,db.json。 主题的分类与标签功能出现“Cannot GET/xxxx”问题没有初始化分类的子目录。当添加一个分类菜单，主题默认中并没有对应页面，需要自己new.hexo new page &quot;tags&quot;sources/tags/index.md,修改type: “tags”,comments: false 设置阅读全文在文章中使用&lt;!-- more --&gt;手动进行截断，此上内容为摘要，并显示阅读全文按钮。 搜索菜单菜单下不需添加search,也不要new page(因为无界面)，启用后会自动添加到最后。 评论、分享系统多说，可自定义css样式，这个可以玩玩 多说热评在标签等页面也显示，不够美观，关掉。以后再研究。 图片对于本地图片，需要在source目录下面新建一个目录images，然后把图片放到目录中.![这是一张图片](/images/fens.me.png)由于github有300M存储空间限制，所以最好使用七牛云图床生成图片外链。 站点统计使用不蒜子。 RSS订阅远程无法更新页面由于之前胡乱操作导致本地目录混乱，于是整理，不小心删除.deploy_git下的.git,导致github远程无法更新静态页面。还原即可。 优化部署与管理hexo deploy只是将.deploy_git(或public?)中的文件即生成的静态网页文件上传到github部署,那我们写的博客源文件及主题如何备份呢？有人提出一种比较好的方案：在远程仓库创建两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 博客搭建流程创建仓库，username.github.io；创建两个分支：master 与 hexo；设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；使用git clone git@github.com:username/username.github.io.git拷贝仓库；username.github.io文件夹下通过Git bash依次执行npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;修改_config.yml中的deploy参数，分支应为master；依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；执行hexo generate -d生成网站并部署到GitHub上。这样一来，username.github.io仓库就有两个分支，一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。 日常修改在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；然后才执行hexo generate -d发布网站到master分支上。 本地资料丢失当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：使用git clone git@github.com:username/username.github.io.git拷贝仓库（默认分支为hexo）；在本地新拷贝的username.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。 这里会有几个问题首先直接将整个hexo目录push到远程。由于一开始是直接clone主题next到hexo目录下的themes下，hexo下就有两个.git，肯定报错。删除及next下的.git，结果文件结构产生混乱。最后是手动删除重复的文件，再add,commit,push。另外还是由于直接clone主题，这时在远程next文件夹是灰的，意味着修改的主题并没有上传。自己琢磨，前面由于next下有.git，可能导致next目录以下有冲突而忽略了此文件夹下的文件，这时只要next没动，怎么改里面的东西都还是不会上传，包括添加.gitkeep都不会有效果。于是 git ls-files，果然没有这些文件。将整个next文件夹剪切到其他位置，add,commit,然后再将next放回，add,commit,push,问题解决！ 总结整个过程很有激情，也学到了很多，包括git、markdown。遇到问题首先看官方文档！首先看官方文档！首先看官方文档！重要的事情说三遍！ 后记博客是初步搭建好了，接下来还需要逐步完善，包括功能完善、自己写一些样式进行界面优化、购买域名、SEO优化等等。最重要的是，希望能够注重内容的建设。可能自己就是个没什么内涵的人，早年间写过一些文字，大多华而不实，后来意识到这点，以至于有些生厌，所以很久没有写作了。希望能够坚持写些东西，不管是技术上的，还是一些生活随笔，贵在坚持。我也希望不久的将来，能够自己创建出一个完整的网站。虽然这条路并没有想象中的平坦，但仍然在朝着这个方向努力，每天有收获的感觉很充实。 参考手把手教你建github技术博客Hexo博客搭建全攻略(一):基于Hexo+Github环境搭建 系列文章使用hexo，如果换了电脑怎么更新博客？Hexo 中文文档Next 使用文档多说不蒜子七牛云]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>github pages</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
